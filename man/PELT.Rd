% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PeltR6.R
\docType{class}
\name{PELT}
\alias{PELT}
\title{Pruned Exact Linear Time (PELT)}
\description{
An R6 class implementing the PELT algorithm for offline change point detection.
}
\details{
PELT (Pruned Exact Linear Time) is an efficient algorithm for change point detection
that prunes the search space to achieve optimal segmentation in linear time under certain conditions.

Currently supported cost functions:
\itemize{
\item \code{"L2"}: for (independent) piecewise Gaussian process with \strong{constant covariance}
\item \code{"SIGMA"}: for (independent) piecewise Gaussian process with \strong{varying covariance}
\item \code{"VAR"}: for piecewise Gaussian vector-regressive process with \strong{constant covariance}
}

See \strong{Methods} section for more details.
}
\section{Methods}{

\describe{
\item{\code{$new()}}{Initialises a PELT object.}
\item{\code{$describe()}}{Describes the PELT object.}
\item{\code{$fit()}}{Takes a time series matrix as input.}
\item{\code{$predict()}}{Performs PELT given a linear penalty value.}
\item{\code{$plot()}}{Plots change point segmentation in ggplot style.}
\item{\code{$clone()}}{Clone the PELT object.}
}
}

\examples{
# Toy example
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,0, 10)))
# Initialise a PELT object and fit the method to tsMat
PELTObj = PELT$new(costFunc = "SIGMA")
PELTObj$fit(tsMat) #Need to run this before running $predict()
# Perform PELT for a specific linear penalty threshold
PELTObj$predict(pen = 50)
# Plot the latest segmentation solution
PELTObj$plot(main = "PELT:SIGMA:pen=50", ncol = 1)
# Describe the PELT object (and invisibly return the object's fields)
PELTObj$describe()


## ------------------------------------------------
## Method `PELT$new`
## ------------------------------------------------

peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")

## ------------------------------------------------
## Method `PELT$describe`
## ------------------------------------------------

PELTObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
PELTObj$describe()


## ------------------------------------------------
## Method `PELT$fit`
## ------------------------------------------------

peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
peltObj$fit(tsMat)

## ------------------------------------------------
## Method `PELT$predict`
## ------------------------------------------------

peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
peltObj$fit(tsMat)
peltObj$predict()

## ------------------------------------------------
## Method `PELT$plot`
## ------------------------------------------------

peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
peltObj$fit(tsMat)
peltObj$predict(pen = 1)
pen1 = peltObj$plot(main = "PELT: pen = 1")
peltObj$predict(pen = 25)
pen25 = peltObj$plot(main = "PELT: pen = 25")
pen1 | pen25
}
\references{
Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods.
Signal Processing, 167, 107299.

Killick, R., Fearnhead, P., & Eckley, I. A. (2012). Optimal detection of change points with a linear computational cost.
Journal of the American Statistical Association, 107(500), 1590-1598.
}
\author{
Minh Long Nguyen \email{edelweiss611428@gmail.com}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{minSize}}{Active binding. Sets the internal variable \code{.minSize} but should not be called directly.}

\item{\code{jump}}{Active binding. Sets the internal variable \code{.jump} but should not be called directly.}

\item{\code{costFunc}}{Active binding. Sets the internal variable \code{.costFunc} but should not be called directly.}

\item{\code{tsMat}}{Active binding. Sets the internal variable \code{.tsMat} but should not be called directly.}

\item{\code{addSmallDiag}}{Active binding. Sets the internal variable \code{.addSmallDiag} but should not be called directly.}

\item{\code{epsilon}}{Active binding. Sets the internal variable \code{.epsilon} but should not be called directly.}

\item{\code{pVAR}}{Active binding. Sets the internal variable \code{.pVAR} but should not be called directly.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PELT-new}{\code{PELT$new()}}
\item \href{#method-PELT-describe}{\code{PELT$describe()}}
\item \href{#method-PELT-fit}{\code{PELT$fit()}}
\item \href{#method-PELT-predict}{\code{PELT$predict()}}
\item \href{#method-PELT-plot}{\code{PELT$plot()}}
\item \href{#method-PELT-clone}{\code{PELT$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-new"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-new}{}}}
\subsection{Method \code{new()}}{
Initialises a PELT object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$new(minSize, jump, costFunc, addSmallDiag, epsilon, pVAR)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{minSize}}{Integer. Minimum allowed segment length. Default: 1L.}

\item{\code{jump}}{Integer. Search grid step size: only positions in \{1, k+1, 2k+1, ...\} are considered. Default: 1L.}

\item{\code{costFunc}}{Character. Cost function to use: one of \code{"L2"}, \code{"SIGMA"}, or \code{"VAR"}. Default: \code{"L2"}.}

\item{\code{addSmallDiag}}{Logical. (SIGMA) If \code{TRUE}, add a small value to the diagonal of estimated covariance matrices
to improve numerical stability. Default: \code{TRUE}.}

\item{\code{epsilon}}{Double. (SIGMA) A small positive value used to the diagonal of estimated covariance matrices to stabilise
matrix operations. Default: \code{1e-6}.}

\item{\code{pVAR}}{Integer (VAR). Order of the vector autoregressive (VAR) model. Must be non-negative. Default: \code{1L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-describe"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-describe}{}}}
\subsection{Method \code{describe()}}{
Describes a PELT object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$describe()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns a list containing some of the following fields:
\describe{
\item{\code{minSize}}{Minimum allowed segment length.}
\item{\code{jump}}{Search grid step size.}
\item{\code{costFunc}}{The cost function.}
\item{\code{addSmallDiag}}{(SIGMA) Whether to add a bias to the diagonal of estimated covariance matrices for numerical stability.}
\item{\code{epsilon}}{(SIGMA) Bias added to diagonal entries.}
\item{\code{pVAR}}{(VAR) VAR order.}
\item{\code{fitted}}{Whether or not \verb{$fit()} has been run.}
\item{\code{tsMat}}{Input time series matrix.}
\item{\code{n}}{Number of observations.}
\item{\code{p}}{Number of features.}
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{PELTObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
PELTObj$describe()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-fit"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-fit}{}}}
\subsection{Method \code{fit()}}{
Takes a time series matrix as input.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$fit(tsMat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tsMat}}{Numeric matrix. A time series matrix of size \eqn{n \times p} whose rows are observations ordered in time.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Initialises \code{private$.tsMat}, \code{private$.n}, and \code{private$.p}, and sets private$.fitted to TRUE,
enabling the use of \verb{$predict()}. Run \verb{$describe()} for detailed configurations.
}

\subsection{Returns}{
Invisibly returns NULL.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
peltObj$fit(tsMat)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-predict"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-predict}{}}}
\subsection{Method \code{predict()}}{
Performs PELT given a linear penalty value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$predict(pen = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pen}}{Numeric. Penalty per change point. Default: \code{0}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Performs PELT given a linear penalty value. Temporary end points are saved
to \code{private$.tmpEndPoints}, allowing users to use  \verb{$plot()} without specifying
end points.
}

\subsection{Returns}{
An integer vector of regime end points. By design, the last element is the
number of observations.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
peltObj$fit(tsMat)
peltObj$predict()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-plot"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-plot}{}}}
\subsection{Method \code{plot()}}{
Plots change point segmentation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$plot(
  d = 1L,
  endPts,
  dimNames,
  main,
  xlab,
  tsWidth = 0.25,
  tsCol = "#5B9BD5",
  bgCol = c("#A3C4F3", "#FBB1BD"),
  bgAlpha = 0.5,
  ncol = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{d}}{Integer vector. Dimensions to plot. Default: \code{1L}.}

\item{\code{endPts}}{Integer vector. End points; defaults to latest temporary changepoints from \verb{$predict()}.}

\item{\code{dimNames}}{Character vector. Feature names matching length of \code{d}. Defaults to \verb{"X1", "X2", ...}.}

\item{\code{main}}{Character. Main title. Defaults to \code{"PELT: d = ..."}.}

\item{\code{xlab}}{Character. X-axis label. Default: \code{"Time"}.}

\item{\code{tsWidth}}{Numeric. Line width for time series and segments. Default: \code{0.25}.}

\item{\code{tsCol}}{Character. Time series color. Default: \code{"#5B9BD5"}.}

\item{\code{bgCol}}{Character vector. Segment colors, recycled to length of \code{endPts}. Default: \code{c("#A3C4F3", "#FBB1BD")}.}

\item{\code{bgAlpha}}{Numeric. Background transparency. Default: \code{0.5}.}

\item{\code{ncol}}{Integer. Number of columns in facet layout. Default: \code{1L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Plots change point segmentation results. Based on ggplot2. Multiple plots can easily be
horizontally and vertically stacked using patchwork's operators \code{/} and \code{|}, respectively.
}

\subsection{Returns}{
An object of classes "gg" and "ggplot".
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
peltObj$fit(tsMat)
peltObj$predict(pen = 1)
pen1 = peltObj$plot(main = "PELT: pen = 1")
peltObj$predict(pen = 25)
pen25 = peltObj$plot(main = "PELT: pen = 25")
pen1 | pen25
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
