% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PeltR6.R
\docType{class}
\name{PELT}
\alias{PELT}
\title{Pruned Exact Linear Time (\code{PELT})}
\description{
An \code{R6} class implementing the PELT algorithm for offline change-point detection.
}
\details{
PELT (Pruned Exact Linear Time) is an efficient algorithm for change point detection
that prunes the search space to achieve optimal segmentation in linear time under
certain conditions.

Currently supports the following cost functions:
\itemize{
\item \code{"L1"} and \code{"L2"} for (independent) piecewise Gaussian process with \strong{constant variance}
\item \code{"SIGMA"}: for (independent) piecewise Gaussian process with \strong{varying variance}
\item \code{"VAR"}: for piecewise Gaussian vector-regressive process with \strong{constant noise variance}
}

\code{PELT} requires  a \code{R6} object of class \code{costFunc}, which can be created via \code{costFunc$new()}.

Basic usage: \url{https://github.com/edelweiss611428/rupturesRcpp/tree/main/README.md}

See \verb{$eval()} method for more details on computation of cost.
}
\section{Methods}{

\describe{
\item{\code{$new()}}{Initialises a \code{PELT} object.}
\item{\code{$describe()}}{Describes the \code{PELT} object.}
\item{\code{$fit()}}{Constructs a \code{PELT} module in \verb{C++}.}
\item{\code{$eval()}}{Evaluate the cost of a segment.}
\item{\code{$predict()}}{Performs \code{PELT} given a linear penalty value.}
\item{\code{$plot()}}{Plots change-point segmentation in \code{ggplot} style.}
\item{\code{$clone()}}{Clones the \code{R6} object.}
}
}

\references{
Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods.
Signal Processing, 167, 107299.

Killick, R., Fearnhead, P., & Eckley, I. A. (2012). Optimal detection of change points with a linear computational cost.
Journal of the American Statistical Association, 107(500), 1590-1598.
}
\author{
Minh Long Nguyen \email{edelweiss611428@gmail.com}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{minSize}}{Integer. Minimum allowed segment length. Can be accessed or modified via \verb{$minSize}.}

\item{\code{jump}}{Integer. Search grid step size. Can be accessed or modified via \verb{$jump}.}

\item{\code{costFunc}}{\code{R6} object of class \code{costFunc}. Search grid step size. Can be accessed or modified via \verb{$costFunc}.}

\item{\code{tsMat}}{Numeric matrix. Input time series matrix of size \eqn{n \times p}. Can be accessed or modified via \verb{$tsMat}.
Modifying \code{tsMat} will automatically trigger \verb{$fit()}.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PELT-new}{\code{PELT$new()}}
\item \href{#method-PELT-describe}{\code{PELT$describe()}}
\item \href{#method-PELT-fit}{\code{PELT$fit()}}
\item \href{#method-PELT-eval}{\code{PELT$eval()}}
\item \href{#method-PELT-predict}{\code{PELT$predict()}}
\item \href{#method-PELT-plot}{\code{PELT$plot()}}
\item \href{#method-PELT-clone}{\code{PELT$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-new"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-new}{}}}
\subsection{Method \code{new()}}{
Initialises a \code{PELT} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$new(minSize, jump, costFunc)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{minSize}}{Integer. Minimum allowed segment length. Default: \code{1L}.}

\item{\code{jump}}{Integer. Search grid step size: only positions in \{1, k+1, 2k+1, ...\} are considered. Default: \code{1L}.}

\item{\code{costFunc}}{A \code{R6} object of class \code{costFunc}. Should be created via \code{costFunc$new()} to avoid error.
Default: \code{costFunc$new("L2")}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns \code{NULL}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-describe"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-describe}{}}}
\subsection{Method \code{describe()}}{
Describes a \code{PELT} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$describe(printConfig = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{printConfig}}{Logical. Whether to print object configurations. Default: \code{FALSE}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns a list storing at least the following fields:

\describe{
\item{\code{minSize}}{Minimum allowed segment length.}
\item{\code{jump}}{Search grid step size.}
\item{\code{costFunc}}{The \code{costFun} object.}
\item{\code{fitted}}{Whether or not \verb{$fit()} has been run.}
\item{\code{tsMat}}{Time series matrix.}
\item{\code{n}}{Number of observations.}
\item{\code{p}}{Number of features.}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-fit"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-fit}{}}}
\subsection{Method \code{fit()}}{
Constructs a \code{PELT} module in \verb{C++}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$fit(tsMat = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tsMat}}{Numeric matrix. A time series matrix of size \eqn{n \times p} whose rows are observations ordered in time.
Default: \code{NULL}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method does the following:
\itemize{
\item Initialises \code{private$.tsMat}, \code{private$.n}, and \code{private$.p}.
\item Constructs a \code{PELT} module in \verb{C++} and sets \code{private$.fitted} to \code{TRUE}, enabling the use of \verb{$predict()} and \verb{$eval()}.
}
}

\subsection{Returns}{
Invisibly returns \code{NULL}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-eval"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-eval}{}}}
\subsection{Method \code{eval()}}{
Evaluate the cost of the segment (a,b]
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$eval(a, b)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Integer. Start index of the segment (exclusive). Must satisfy \code{start < end}.}

\item{\code{b}}{Integer. End index of the segment (inclusive).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The segment cost is evaluated as follows:
\itemize{
\item \strong{L1 cost function}:
\deqn{c_{L_1}(y_{(a+1)...b}) := \sum_{t = a+1}^{b} \| y_t - \tilde{y}_{(a+1)...b} \|_1}
where \eqn{\tilde{y}_{(a+1)...b}} is the coordinate-wise median of the segment. If \eqn{a \ge b - 1}, return 0.
\item \strong{L2 cost function}:
\deqn{c_{L_2}(y_{(a+1)...b}) := \sum_{t = a+1}^{b} \| y_t - \bar{y}_{(a+1)...b} \|_2^2}
where \eqn{\bar{y}_{(a+1)...b}} is the empirical mean of the segment. If \eqn{a \ge b - 1}, return 0.
\item \strong{SIGMA cost function}:
\deqn{c_{\sum}(y_{(a+1)...b}) := (b - a)\log \det \hat{\Sigma}_{(a+1)...b}} where \eqn{\hat{\Sigma}_{(a+1)...b}} is
the empirical covariance matrix of the segment without Bessel's correction. Here, if \code{addSmallDiag = TRUE}, a small
bias \code{epsilon} is added to the diagonal of estimated covariance matrices to improve numerical stability. \cr
\cr
By default, \code{addSmallDiag = TRUE} and \code{epsilon = 1e-6}. In case \code{addSmallDiag = TRUE}, if the computed determinant of covariance matrix is either 0 (singular)
or smaller than \code{p*log(epsilon)} - the lower bound, return \code{(b - a)*p*log(epsilon)}, otherwise, output an error message.
\item \strong{VAR(r) cost function}:
\deqn{c_{\mathrm{VAR}}(y_{(a+1)...b}) := \sum_{t = a+r+1}^{b} \left\| y_t - \sum_{j=1}^r \hat A_j y_{t-j} \right\|_2^2}
where \eqn{\hat A_j} are the estimated VAR coefficients, commonly estimated via the OLS criterion. If system is singular,
\eqn{a-b < p*r+1} (i.e., not enough observations), or \eqn{a \ge n-p} (where \code{n} is the time series length), return 0.
}
}

\subsection{Returns}{
The segment cost.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-predict"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-predict}{}}}
\subsection{Method \code{predict()}}{
Performs \code{PELT} given a linear penalty value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$predict(pen = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pen}}{Numeric. Penalty per change-point. Default: \code{0}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Performs \code{PELT} given a linear penalty value. Temporary end points are saved
to \code{private$.tmpEndPoints}, allowing users to use \verb{$plot()} without specifying
end points.
}

\subsection{Returns}{
An integer vector of regime end-points. By design, the last element is the
number of observations \code{private$.n}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-plot"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-plot}{}}}
\subsection{Method \code{plot()}}{
Plots change-point segmentation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$plot(
  d = 1L,
  endPts,
  dimNames,
  main,
  xlab,
  tsWidth = 0.25,
  tsCol = "#5B9BD5",
  bgCol = c("#A3C4F3", "#FBB1BD"),
  bgAlpha = 0.5,
  ncol = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{d}}{Integer vector. Dimensions to plot. Default: \code{1L}.}

\item{\code{endPts}}{Integer vector. End points. Default: latest temporary changepoints obtained via \verb{$predict()}.}

\item{\code{dimNames}}{Character vector. Feature names matching length of \code{d}. Defaults to \verb{"X1", "X2", ...}.}

\item{\code{main}}{Character. Main title. Defaults to \code{"PELT: d = ..."}.}

\item{\code{xlab}}{Character. X-axis label. Default: \code{"Time"}.}

\item{\code{tsWidth}}{Numeric. Line width for time series and segments. Default: \code{0.25}.}

\item{\code{tsCol}}{Character. Time series color. Default: \code{"#5B9BD5"}.}

\item{\code{bgCol}}{Character vector. Segment colors, recycled to length of \code{endPts}. Default: \code{c("#A3C4F3", "#FBB1BD")}.}

\item{\code{bgAlpha}}{Numeric. Background transparency. Default: \code{0.5}.}

\item{\code{ncol}}{Integer. Number of columns in facet layout. Default: \code{1L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Plots change-point segmentation results. Based on \code{ggplot2}. Multiple plots can easily be
horizontally and vertically stacked using \code{patchwork}'s operators \code{/} and \code{|}, respectively.
}

\subsection{Returns}{
An object of classes \code{gg} and \code{ggplot}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PELT-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PELT-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PELT$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
