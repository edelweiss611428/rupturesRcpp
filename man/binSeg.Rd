% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/binSegR6.R
\docType{class}
\name{binSeg}
\alias{binSeg}
\title{Binary Segmentation (binSeg)}
\description{
Binary Segmentation (binSeg)

Binary Segmentation (binSeg)
}
\details{
An R6 class implements binSeg for offline changepoint detection, currently only supports the L2 cost function.
}
\examples{

## ------------------------------------------------
## Method `binSeg$new`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")

## ------------------------------------------------
## Method `binSeg$describe`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
binSegObj$describe()


## ------------------------------------------------
## Method `binSeg$fit`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)

## ------------------------------------------------
## Method `binSeg$predict`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
binSegObj$predict(pen = NULL)
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{minSize}}{An active binding. Sets the internal variable \code{.minSize} but should not be called directly.}

\item{\code{jump}}{An active binding. Sets the internal variable \code{.jump} but should not be called directly.}

\item{\code{costFunc}}{An active binding. Sets the internal variable \code{.costFunc} but should not be called directly.}

\item{\code{tsMat}}{An active binding. Sets the internal variable \code{.tsMat} but should not be called directly.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-binSeg-new}{\code{binSeg$new()}}
\item \href{#method-binSeg-describe}{\code{binSeg$describe()}}
\item \href{#method-binSeg-fit}{\code{binSeg$fit()}}
\item \href{#method-binSeg-predict}{\code{binSeg$predict()}}
\item \href{#method-binSeg-clone}{\code{binSeg$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-new"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-new}{}}}
\subsection{Method \code{new()}}{
Initialises a binSeg object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{minSize}}{An integer specifying the minimum segment size. By default, minSize = 1L.}

\item{\code{jump}}{An integer $k$ defining the search grid - only candidate changepoints in \{1,k+1,2k+1,...\}
will be considered. By default, jump = 1L.}

\item{\code{costFunc}}{A string specifying a cost function. Currently, only "L2" is supported.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns NULL. Creates a binSeg object with params minSize, jump, and costFunc.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-describe"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-describe}{}}}
\subsection{Method \code{describe()}}{
Describes a binSeg object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$describe()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns a list containing the following fields of the binSeg object:
\describe{
\item{\code{minSize}}{The minimum segment size.}
\item{\code{jump}}{The integer $k$ defining the search grid \{1,k+1,2k+1,...\}.}
\item{\code{costFunc}}{The cost function.}
\item{\code{fitted}}{A boolean indicating whether or not $fit() has been run.}
\item{\code{tsMat}}{The input time series matrix.}
\item{\code{n}}{The number of observations in tsMat.}
\item{\code{p}}{The number of features in tsMat.}
\item{\code{bkps}}{A vector containing unordered breakpoint positions, given the maximum number of allowable breakpoints.}
\item{\code{cost}}{From the second elemement, the corresponding costs of splits in bkps. By default, the
first element is the total cost without any split}
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
binSegObj$describe()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-fit"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-fit}{}}}
\subsection{Method \code{fit()}}{
Takes a time series matrix as input and perform binSeg for the
maximum number of changepoints.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$fit(tsMat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tsMat}}{tsMat A time series matrix of size \eqn{n \times p} whose rows are observations ordered in time.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns NULL. Initialises .tsMat, .n, and .p, and sets private$.fitted to TRUE,
enabling the use of $predict().
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-predict"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-predict}{}}}
\subsection{Method \code{predict()}}{
Performs binSeg given a linear penalty value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$predict(pen = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pen}}{A single non-negative numeric value specifying a penalty for each additional changepoint. By default,
pen = NULL, which forces pen = 2*log(n).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector of indexes corresponding to the end point of each regime. By design, the last element
of the vector is the number of observations.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
binSegObj$predict(pen = NULL)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-clone"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
