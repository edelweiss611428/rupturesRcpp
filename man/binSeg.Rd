% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/binSegR6.R
\docType{class}
\name{binSeg}
\alias{binSeg}
\title{Binary Segmentation (binSeg)}
\description{
An R6 class implementing binary segmentation for offline change point detection.
}
\details{
Binary segmentation is a classic algorithm for change point detection that recursively
splits the data at locations that minimise the cost function.

Currently supported cost functions:
\itemize{
\item \code{"L2"}: for (independent) piecewise Gaussian process with \strong{constant covariance}
\item \code{"SIGMA"}: for (independent) piecewise Gaussian process with \strong{varying covariance}
\item \code{"VAR"}: for piecewise Gaussian vector-regressive process with \strong{constant covariance}
}

See \strong{Methods} and section for more details.
}
\section{Methods}{

\describe{
\item{\code{$new()}}{Initialises a binSeg object.}
\item{\code{$describe()}}{Describes the binSeg object.}
\item{\code{$fit()}}{Takes a time series matrix as input and perform binSeg for the
maximum number of change points.}
\item{\code{$predict()}}{Performs binSeg given a linear penalty value.}
\item{\code{$plot()}}{Plots change point segmentation in ggplot style.}
\item{\code{$clone()}}{Clone the binSeg object.}
}
}

\examples{
# Toy example
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,0, 10)))
# Initialise a binSeg object and fit the method to tsMat
binSegObj = binSeg$new(costFunc = "SIGMA")
binSegObj$fit(tsMat) #Need to run this before running $predict()
# Perform binSeg for a specific linear penalty threshold
binSegObj$predict(pen = 50)
# Plot the latest segmentation solution
binSegObj$plot(main = "binSeg:SIGMA:pen=50", ncol = 1)
# Describe the binSeg object (and invisibly return the object's fields)
binSegObj$describe()


## ------------------------------------------------
## Method `binSeg$new`
## ------------------------------------------------

peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")

## ------------------------------------------------
## Method `binSeg$describe`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
binSegObj$describe()


## ------------------------------------------------
## Method `binSeg$fit`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)

## ------------------------------------------------
## Method `binSeg$predict`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
binSegObj$predict()

## ------------------------------------------------
## Method `binSeg$plot`
## ------------------------------------------------

binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
binSegObj$predict(pen = 1)
pen1 = binSegObj$plot(main = "binSeg: pen = 1")
binSegObj$predict(pen = 25)
pen25 = binSegObj$plot(main = "binSeg: pen = 25")
pen1 | pen25
}
\references{
Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods.
Signal Processing, 167, 107299.

Hocking, T. D. (2024). Finite Sample Complexity Analysis of Binary Segmentation. arXiv preprint arXiv:2410.08654.
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{minSize}}{An active binding. Sets the internal variable \code{.minSize} but should not be called directly.}

\item{\code{jump}}{An active binding. Sets the internal variable \code{.jump} but should not be called directly.}

\item{\code{costFunc}}{An active binding. Sets the internal variable \code{.costFunc} but should not be called directly.}

\item{\code{tsMat}}{An active binding. Sets the internal variable \code{.tsMat} but should not be called directly.}

\item{\code{addSmallDiag}}{An active binding. Sets the internal variable \code{.addSmallDiag} but should not be called directly.}

\item{\code{epsilon}}{An active binding. Sets the internal variable \code{.epsilon} but should not be called directly.}

\item{\code{pVAR}}{An active binding. Sets the internal variable \code{.pVAR} but should not be called directly.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-binSeg-new}{\code{binSeg$new()}}
\item \href{#method-binSeg-describe}{\code{binSeg$describe()}}
\item \href{#method-binSeg-fit}{\code{binSeg$fit()}}
\item \href{#method-binSeg-predict}{\code{binSeg$predict()}}
\item \href{#method-binSeg-plot}{\code{binSeg$plot()}}
\item \href{#method-binSeg-clone}{\code{binSeg$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-new"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-new}{}}}
\subsection{Method \code{new()}}{
Initialises a binSeg object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$new(minSize, jump, costFunc, addSmallDiag, epsilon, pVAR)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{minSize}}{An integer specifying the minimum segment size. By default, minSize = 1L.}

\item{\code{jump}}{An integer k defining the search grid - only candidate change points in \{1,k+1,2k+1,...\}
will be considered. By default, jump = 1L.}

\item{\code{costFunc}}{A character specifying a cost function. Currently, only "L2", "SIGMA", and "VAR" are supported. By default,
costFunc = "L2".}

\item{\code{addSmallDiag}}{(SIGMA) An boolean value indicating whether or not to add a small bias to the diagonal entries
of estimated covariance matrices (for costFunc "SIGMA"). This improves numerical stability in near-singularity
scenarios. By default, addSmallDiag = TRUE.}

\item{\code{epsilon}}{(SIGMA) A double value specifying a bias value to be added to the diagonal entries
of estimated covariance matrices. By default, epsilon = 10^-6.}

\item{\code{pVAR}}{(VAR) A non-negative integer specify vector-autoregressive order. By default, pVAR = 1.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns NULL. Creates a PELT object with params minSize, jump, and costFunc.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{peltObj = PELT$new(minSize = 1L, jump = 1L, costFunc = "L2")
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-describe"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-describe}{}}}
\subsection{Method \code{describe()}}{
Describes a binSeg object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$describe()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns a list containing the following fields of the binSeg object:
\describe{
\item{\code{minSize}}{The minimum segment size.}
\item{\code{jump}}{The integer k defining the search grid \{1,k+1,2k+1,...\}.}
\item{\code{costFunc}}{The cost function.}
\item{\code{addSmallDiag}}{A boolean value indicating whether to add a bias value to diagonal entries of estimated covariance matrices.}
\item{\code{epsilon}}{The bias value to be added to diagonal entries of estimated covariance matrices.}
\item{\code{fitted}}{A boolean indicating whether or not $fit() has been run.}
\item{\code{tsMat}}{The input time series matrix.}
\item{\code{n}}{The number of observations in tsMat.}
\item{\code{p}}{The number of features in tsMat.}
\item{\code{bkps}}{A vector containing unordered breakpoint positions, given the maximum number of allowable breakpoints.}
\item{\code{cost}}{From the second elemement, the corresponding costs of splits in bkps. By default, the
first element is the total cost without any split}
}
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
binSegObj$describe()

}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-fit"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-fit}{}}}
\subsection{Method \code{fit()}}{
Takes a time series matrix as input and perform binSeg for the
maximum number of change points.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$fit(tsMat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tsMat}}{tsMat A time series matrix of size \eqn{n \times p} whose rows are observations ordered in time.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns NULL. Initialises .tsMat, .n, and .p, and sets private$.fitted to TRUE,
enabling the use of $predict().
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-predict"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-predict}{}}}
\subsection{Method \code{predict()}}{
Performs binSeg given a linear penalty value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$predict(pen = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pen}}{A single non-negative numeric value specifying a penalty for each additional change point. By default,
pen = 0.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A vector of indexes corresponding to the end point of each regime. By design, the last element
of the vector is the number of observations. Temporary end points are saved to private$.tmpEndPoints,
which allows users to usethe $plot() method without specifying end points.
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
binSegObj$predict()
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-plot"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-plot}{}}}
\subsection{Method \code{plot()}}{
Plots change point segmentation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$plot(
  d = 1L,
  endPts,
  dimNames,
  main,
  xlab,
  tsWidth = 0.25,
  tsCol = "#5B9BD5",
  bgCol = c("#A3C4F3", "#FBB1BD"),
  bgAlpha = 0.5,
  ncol = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{d}}{An integer vector specifying dimensions to plot. By default, d = 1L.}

\item{\code{endPts}}{An integer vector specifying end points! Could be obtained via $predict().").
By default, endPts is missing, in which, the method will proceed to use the (latest) temporary
changepoints obtained by running $predict().}

\item{\code{dimNames}}{A character vector specifying feature names!", whose length must match that of d if not missing.
By default, dimNames is missing, which forces dimNames = ("X1", "X2",...).}

\item{\code{main}}{A character specifying the main title of the plot. By default, main is missing, in which the method
will use the default title "binSeg: d = ...".}

\item{\code{xlab}}{A character specifying the x-axis label. By default, xlab is missing, which force xlab = "Time".}

\item{\code{tsWidth}}{A numeric value specifying the linewidth of the time series and also that of the segments' dashed lines.
By default, tsWidth = 0.25.}

\item{\code{tsCol}}{A character color of the plotted time series. By default, tsCol = "#5B9BD5".}

\item{\code{bgCol}}{A character vector specifying segment colors. This will be repeated up to the length of
endPts. By defaults, bgCol = c("#A3C4F3", "#FBB1BD").}

\item{\code{bgAlpha}}{A numeric value specifying the degree of transparency of the background.
By default, bgAlpha = 0.5.}

\item{\code{ncol}}{An integer specifying the number of columns to be used in the facet layout. By default, ncol  = 1L.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Plots change point segmentation results. Based on ggplot2. Multiple plots can easily be
combined using / (vertically) and | (horizontally) operator via patchwork.
}

\subsection{Returns}{
An object of classes "gg"/"ggplot".
}
\subsection{Examples}{
\if{html}{\out{<div class="r example copy">}}
\preformatted{binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFunc = "L2")
tsMat = as.matrix(c(rnorm(100,0), rnorm(100,5)))
binSegObj$fit(tsMat)
binSegObj$predict(pen = 1)
pen1 = binSegObj$plot(main = "binSeg: pen = 1")
binSegObj$predict(pen = 25)
pen25 = binSegObj$plot(main = "binSeg: pen = 25")
pen1 | pen25
}
\if{html}{\out{</div>}}

}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-clone"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
