% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/binSegR6.R
\docType{class}
\name{binSeg}
\alias{binSeg}
\title{Binary Segmentation (binSeg)}
\description{
An R6 class implementing binary segmentation for offline change point detection.
}
\details{
Binary segmentation is a classic algorithm for change point detection that recursively
splits the data at locations that minimise the cost function.

Currently supports the following cost functions:
\itemize{
\item \code{"L2"}: for (independent) piecewise Gaussian process with \strong{constant variance}
\item \code{"SIGMA"}: for (independent) piecewise Gaussian process with \strong{varying variance}
\item \code{"VAR"}: for piecewise Gaussian vector-regressive process with \strong{constant variance}
}

\code{binSeg} requires  a \code{costFunc} object, which can be created via \code{createCostFunc()}.

Basic usage: \url{https://github.com/edelweiss611428/rupturesRcpp/tree/main/README.md}

See \code{PELT$eval()} method for more details on computation of cost.
}
\section{Methods}{

\describe{
\item{\code{$new()}}{Initialises a \code{binSeg} object.}
\item{\code{$describe()}}{Describes the \code{binSeg} object.}
\item{\code{$fit()}}{Takes a time series matrix as input and perform \code{binSeg} for the
maximum number of change points.}
\item{\code{$predict()}}{Performs binSeg given a linear penalty value.}
\item{\code{$plot()}}{Plots change point segmentation in ggplot style.}
\item{\code{$clone()}}{Clones the \code{binSeg} object.}
}
}

\examples{

# 2-regime simulated data example
set.seed(1)
tsMat = cbind(c(rnorm(100,0), rnorm(100,5,5)),
              c(rnorm(100,0), rnorm(100,5,5)))
# Create a `"SIGMA` cost object.
SIGMAObj = createCostFunc(costFunc = "SIGMA")
# Initialise a `binSeg` object
binSegObj = binSeg$new(minSize = 1L, jump = 1L, costFuncObj = SIGMAObj)
# Input the time series matrix and perform binary segmentation for the maximum number of regimes
binSegObj$fit(tsMat)
# Describe the `binSeg` object
binSegObj$describe()
# Perform binSeg with `pen = 100`
binSegObj$predict(pen = 100)
# Plot the segmentation results
binSegObj$plot(d = 1:2, main = "method: binSeg; costFunc: SIGMA; pen: 100")

}
\references{
Truong, C., Oudre, L., & Vayatis, N. (2020). Selective review of offline change point detection methods.
Signal Processing, 167, 107299.

Hocking, T. D. (2024). Finite Sample Complexity Analysis of Binary Segmentation. arXiv preprint arXiv:2410.08654.
}
\author{
Minh Long Nguyen \email{edelweiss611428@gmail.com}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{minSize}}{Active binding. Sets the internal variable \code{.minSize} but should not be called directly.}

\item{\code{jump}}{Active binding. Sets the internal variable \code{.jump} but should not be called directly.}

\item{\code{costFuncObj}}{Active binding. Sets the internal variable \code{.costFuncObj} but should not be called directly.}

\item{\code{tsMat}}{Active binding. Sets the internal variable \code{.tsMat} but should not be called directly.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-binSeg-new}{\code{binSeg$new()}}
\item \href{#method-binSeg-describe}{\code{binSeg$describe()}}
\item \href{#method-binSeg-fit}{\code{binSeg$fit()}}
\item \href{#method-binSeg-eval}{\code{binSeg$eval()}}
\item \href{#method-binSeg-predict}{\code{binSeg$predict()}}
\item \href{#method-binSeg-plot}{\code{binSeg$plot()}}
\item \href{#method-binSeg-clone}{\code{binSeg$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-new"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-new}{}}}
\subsection{Method \code{new()}}{
Initialises a \code{binSeg} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$new(minSize, jump, costFuncObj)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{minSize}}{Integer. Minimum allowed segment length. Default: \code{1L}.}

\item{\code{jump}}{Integer. Search grid step size: only positions in \{1, k+1, 2k+1, ...\} are considered. Default: \code{1L}.}

\item{\code{costFuncObj}}{List of class \code{costFunc}. Should be created via \code{createFuncObj()} to avoid unintended error.
Default, \code{createFuncObj("L2")}.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Invisibly returns \code{NULL}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-describe"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-describe}{}}}
\subsection{Method \code{describe()}}{
Describes a \code{binSeg} object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$describe()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Invisibly returns a list containing some of the following fields:
\describe{
\item{\code{minSize}}{Minimum allowed segment length.}
\item{\code{jump}}{Search grid step size.}
\item{\code{costFuncObj}}{The \code{costFun} object.}
\item{\code{fitted}}{Whether or not \verb{$fit()} has been run.}
\item{\code{tsMat}}{Input time series matrix.}
\item{\code{n}}{Number of observations.}
\item{\code{p}}{Number of features.}
\item{\code{bkps}}{Vector of unordered breakpoint positions.}
\item{\code{cost}}{From the second element, split costs corresponding to \code{bkps}; first element is total cost without splits.}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-fit"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-fit}{}}}
\subsection{Method \code{fit()}}{
Takes a time series matrix as input and performs binSeg for the
maximum number of change points.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$fit(tsMat)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tsMat}}{Numeric matrix. A time series matrix of size \eqn{n \times p} whose rows are observations ordered in time.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
This method does the following:
\itemize{
\item Initialises \code{private$.tsMat}, \code{private$.n}, and \code{private$.p}.
\item Sets \code{private$.fitted} to \code{TRUE}, enabling the use of \verb{$predict()} and \verb{$eval()}.
\item Initialises a cost module corresponding to \code{tsMat} and the \code{costFunc}
object, enabling the use of \verb{$eval()}.
\item Performs binSeg for the maximum number of change points, making \verb{$predict()}
more efficient.
}
}

\subsection{Returns}{
Invisibly returns \code{NULL}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-eval"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-eval}{}}}
\subsection{Method \code{eval()}}{
Evaluate the cost of the segment (a,b]
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$eval(a, b)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{a}}{Integer. Start index of the segment (exclusive). Must satisfy \code{start < end}.}

\item{\code{b}}{Integer. End index of the segment (inclusive).}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
The segment cost is evaluated as follows:
\itemize{
\item \strong{L2 cost function}:
\deqn{c_{L_2}(y_{(a+1)...b}) := \sum_{t = a+1}^{b} \| y_t - \bar{y}_{(a+1)...b} \|_2^2}
where \eqn{\bar{y}_{(a+1)...b}} is the empirical mean of the segment. If
\code{a+1 = b}, return 0.
\item \strong{SIGMA cost function}:
\deqn{c_{\sum}(y_{(a+1)...b}) := (b - a)\log \det \hat{\Sigma}_{(a+1)...b}} where \eqn{\hat{\Sigma}_{(a+1)...b}} is
the empirical covariance matrix of the segment without Bessel correction. Here, if \code{addSmallDiag = TRUE}, a small
bias \code{epsilon} is added to the diagonal of estimated covariance matrices to improve numerical stability. If
\eqn{\hat{\Sigma}} is singular, return 0. If \code{a+1 = b}, return 0.
\item \strong{VAR(r) cost function}:
\deqn{c_{\mathrm{VAR}}(y_{(a+1)...b}) := \sum_{t = a+r+1}^{b} \left\| y_t - \sum_{j=1}^r \hat A_j y_{t-j} \right\|_2^2}
where \eqn{\hat A_j} are the estimated VAR coefficients, commonly estimated via the OLS criterion. An approximate linear
solver will be used when exact \code{arma::solve()} fails. If no solution found, return 0. If \code{a-b < p*r+1} (i.e., not enough observations),
return 0.
}
}

\subsection{Returns}{
The segment cost
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-predict"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-predict}{}}}
\subsection{Method \code{predict()}}{
Performs binSeg given a linear penalty value.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$predict(pen = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pen}}{Numeric. Penalty per change point. Default: \code{0}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Performs binSeg given a linear penalty value. Temporary end points are saved
to \code{private$.tmpEndPoints}, allowing users to use \verb{$plot()} without specifying
end points.
}

\subsection{Returns}{
An integer vector of regime end points. By design, the last element is the
number of observations.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-plot"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-plot}{}}}
\subsection{Method \code{plot()}}{
Plots change point segmentation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$plot(
  d = 1L,
  endPts,
  dimNames,
  main,
  xlab,
  tsWidth = 0.25,
  tsCol = "#5B9BD5",
  bgCol = c("#A3C4F3", "#FBB1BD"),
  bgAlpha = 0.5,
  ncol = 1L
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{d}}{Integer vector. Dimensions to plot. Default: \code{1L}.}

\item{\code{endPts}}{Integer vector. End points; defaults to latest temporary changepoints from \verb{$predict()}.}

\item{\code{dimNames}}{Character vector. Feature names matching length of \code{d}. Defaults to \verb{"X1", "X2", ...}.}

\item{\code{main}}{Character. Main title. Defaults to \code{"binSeg: d = ..."}.}

\item{\code{xlab}}{Character. X-axis label. Default: \code{"Time"}.}

\item{\code{tsWidth}}{Numeric. Line width for time series and segments. Default: \code{0.25}.}

\item{\code{tsCol}}{Character. Time series color. Default: \code{"#5B9BD5"}.}

\item{\code{bgCol}}{Character vector. Segment colors, recycled to length of \code{endPts}. Default: \code{c("#A3C4F3", "#FBB1BD")}.}

\item{\code{bgAlpha}}{Numeric. Background transparency. Default: \code{0.5}.}

\item{\code{ncol}}{Integer. Number of columns in facet layout. Default: \code{1L}.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Plots change point segmentation results. Based on \code{ggplot2}. Multiple plots can easily be
horizontally and vertically stacked using \code{patchwork}'s operators \code{/} and \code{|}, respectively.
}

\subsection{Returns}{
An object of classes \code{gg} and \code{ggplot}.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-binSeg-clone"></a>}}
\if{latex}{\out{\hypertarget{method-binSeg-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{binSeg$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
